from __future__ import print_function
import math
import random

import numpy as np

import settings


########## Functions ##########


def branch_p(tips, t, dt, h):
    '''Branch probablity.
    See documentation for function details.'''

    # Expected number of branching events at an isolated segment with infinite
    # period of time.
    B = settings.BRANCH_COUNT_INFINITE
    # Exponetial decay parameter in baseline branching rate.
    tau = settings.BRANCH_DECAY_TAU
    # Branching competetion parameter between tip nodes.
    E = settings.BRANCH_COMPETETION_E
    # Parameter determine influence of segments with different heights.
    S = settings.TOPOLOGICAL_PARA_S
    # Number of total terminal tips.
    n = len(tips)
    # Centrifugal base.
    C = 0
    for tip in tips:
        C += 2 ** (-S * tip.height)
    C = C/n
    # Calculate probablity.
    p = (n ** -E)*B*math.exp(-t/tau)*(math.exp(dt/tau)-1)*(2 ** (-S*h))/C

    return p


########## Classes ##########


class Node():
    '''Node class.
    Used to represent end point of segments in branches.'''

    # Read simulating settings from settings file.
    ave_velocity = settings.AVE_VELOCITY
    init_len = settings.INIT_LEN
    timestep = settings.TIMESTEP

    def __init__(self, coor, parent, slope=None, height=None, branch=None):
        self.coor = coor
        self.parent = parent
        # Calculate height from parent's height if no height is specified.
        self.height = height if height else parent.height + 1
        self.slope = slope
        self.branch = branch

    @property
    def root(self):
        '''Return the root node of the branch that current node belongs to.
        For root node r, r.parent = None .
        TODO: if this method is taking too much time. consider to rewrite this
        method as a property points to the root node.'''
        ancestor = self.parent
        # Look for ancestors if self.parent is not None.
        if ancestor:
            while ancestor.parent:
                ancestor = ancestor.parent
            return ancestor
        else:
            return self

    @property
    def leaves(self):
        '''Return all leaves in the subtree rooted at current node.
        Find leaves recursively.
        TODO: if this method is taking too much time, consider to
        rewrite it iteratively.'''
        leaves = []
        if self.left:
            leaves += self.left.leaves
        elif self.right:
            leaves += self.right.leaves
        else:
            leaves.append(self)
        return leaves

    def velocity(self):
        '''Return a velocity randomly sampled from a Gaussian distribution.'''

        # Set Gaussian distribution parameters.
        # Mean
        mu = Node.ave_velocity
        # Standard deviation.
        sigma = mu

        return np.random.normal(mu, sigma)


    def need_branch(self, t):
        '''Determine whether a tip node needs to branch at a timestep.
        Generate a random number r in [0,1) and compare it with the
        probablity generated by p = branch_p(n, t, dt, h). Return True if r is
        smaller than p, else return False.
        '''

        r = random.random()
        # Time now
        time_now = t * Node.timestep
        # All terminal tips.
        tips = self.root.leaves
        # Branching probablity.
        prob_branch = branch_p(tips, time_now, Node.timestep, self.height)

        if r <= prob_branch:
            return True
        else:
            return False






class Branch():
    '''Branch class.
    Each neuron has several branches which are consisted by many
    segments.'''

    def __init__(self, ):
        self.root = Node()
